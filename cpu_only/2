/*  Project:                ECE 408 Final Project
 *  File Name:              recalculate_grid_cpu.cpp
 *  Calls:                  none
 *  Called by:              main.cpp
 *  Associated Header:      ece408_final_cpu.h
 *  Date created:           Sat Nov 7 2015
 *  Engineers:              TODO
 *  Compiler:               g++
 *  Target OS:              Ubuntu Linux 14.04
 *  Target architecture:    x86 (64 bit)
 *  Description:            Reads an input cell grid, computes the next generation (step)
 *                          and writes it to the output grid */

#include <cstring>
#include <cstdio>


bool get_cell
(
    const unsigned char* input_cell_grid,
    int x,
    int y,
    unsigned width,
    unsigned height
){
    // Simply return if the cell at the given (x,y) coordinate is alive
    // Check that x,y are inside bounds of grid
    if (x >= (int)width || y >= (int)height || x < 0 || y < 0)
        return false;

    unsigned int remainder = (unsigned int)(x % 8);
    unsigned char mask = 0x1 << remainder;
    unsigned char cell_char = input_cell_grid[y * ((width-1)/8 +1) + x/8];
    unsigned char masked_char = cell_char & mask;
	//printf("get_cell is returning %u\n", masked_char != 0);
    return masked_char != 0;
}

void write_cell
(
	bool alive,
	int x,
	int y,
	unsigned width,
	unsigned height,
	unsigned char* output_cell_grid
){
    unsigned int remainder = x % 8;
	unsigned char cell_char = output_cell_grid[y * ((width-1)/8 +1) + x/8];
	// This line should be considered for cells to be set to dead if the output grid is garbage
//	unsigned char mask = (alive) ? 0xFF : !(0x1 << remainder);
	unsigned char mask = alive ? (0x1 << remainder) : 0;
	unsigned char masked_char = cell_char | mask;
	output_cell_grid[y * ((width-1)/8 +1) + x/8] = masked_char;
	printf("mask: %u\n", mask);

}
    

void recalculate_grid_cpu
(
    unsigned char* output_cell_grid,
    const unsigned char* input_cell_grid,
    unsigned width,
    unsigned height
){
    
    // TODO - Laura or Peter.  Compute the next generation of cells (one step)
    // if you don't like the function prototype, feel free to change it.
    // You can erase these comments when you're done, they're mostly to get you started
    //
    // Let's stick to the standard rules (quoted from wikipedia)
    // 1) Any live cell with fewer than two live neighbours dies, as if caused by under-population.
    // 2) Any live cell with two or three live neighbours lives on to the next generation.
    // 3) Any live cell with more than three live neighbours dies, as if by over-population.
    // 4) Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
    //
    // and...
    //
    // if a cell is on a boundary, non-existent neighbors should be counted as dead cells.
    
    // some hints for accessing cells: (see pngrw.h)
    // cell_grid[0] & 0x1 is the cell in the upper-left corner
    // (cell_grid[0] & 0x2) >> 1 is the next cell to the right
    // cell_grid[1] & 0x1 is the 8th cell to the right of the upper left corner
    // Bits are 1 for live cells and 0 for dead cells.
    
    // TODO to test your code, just type make -j valgrind in the terminal.
    // you can look at the output pngs named generation_xx.png to verify that your code works
    // the version of the code that I uploaded functions with no valgrind errors, but that
    // it is still possible that there are bugs in what I've written.  Let me know if you
    // suspect this
    
    // TODO - update "ece408_final_cpu.h" when you finish this function
    // Please update the "Engineers" space at the top of this file with your name.  If someone
    // else has a question, they will know who to ask ;)

    // Laura's basic idea: loop through every x and y, count the number of alive neighbors,
    // apply the rule, fill in output_cell_grid
    for (int x = 0; x < (int)width; x++) {
        for (int y = 0; y < (int)height; y++) {
			int neighbor_sum = 0;
			bool curr_cell_alive = get_cell(input_cell_grid, x, y, width, height);
			printf("Current cell alive: %u\n", curr_cell_alive);
			bool next_cell_alive = curr_cell_alive;
			//get sum of neighbors
            for(int j = -1; j < 2; j++) {
				for(int i = -1; i < 2; i++) {
					if (i != 0 || j != 0)
					{
						if (get_cell(input_cell_grid, x+i, y+j, width, height)) {
							neighbor_sum++;
						}
					}	
				}
			}
			//check rules
			printf("neighbor sum is %d\n",neighbor_sum);
			if(curr_cell_alive)
			{
				//printf("The cell is alive!\n");
				if(neighbor_sum < 2)//under-population rule
					next_cell_alive = false;
				else if(neighbor_sum < 4)
					next_cell_alive = true;
				else
					next_cell_alive = false;
			}
			else
			{
				if(neighbor_sum == 3)
					next_cell_alive = true;
				else
					next_cell_alive = false;
			}
			printf("Is the next cell alive? %u\n", next_cell_alive);
			write_cell(next_cell_alive, x, y, width, height, output_cell_grid);


        }
    }
    
    // remove the line below, it just copies the input to the output ;)
    // Laura: judging by the memcpy line below, to cover extra (x%8) cells at the end of a
    // line, there is an extra char to hold that info
    // For example, if there are 65 cells in one horizontal line of the grid, there must be
    // 9 chars to hold them; 64 cells->8 chars, 63 cells->8 chars
    // So, to access any cell (x,y): input_cell_grid[y * ((width-1)/8 +1) + x/8] is the right char
    // and 2^(x%8) gives you the correct power-of-2 mask to use on the char
    // If the result is not zero, that means that the cell in question is alive:
    // cell_alive = (input_cell_grid[y*((width-1)/8+1) + x/8] & pow(2.0, (double)(x%8))) != 0;
    //memcpy(output_cell_grid, input_cell_grid, ((width - 1) / 8 + 1) * height * sizeof(char));

}
